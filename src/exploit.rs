use std::time::{Instant, Duration};
use std::path::Path;
use std::collections::HashMap;
use crate::team::Team;
use crate::flag_submitter::FlagOccurence;

#[derive(Debug)]
pub struct Policy {
    /// Description of the settings.
    name: String,
    /// The template pattern containing the full command and arguments to start the exploit.
    argv_pattern: String,
    /// Time after which the exploit should be run again.
    repeat_interval: Duration,
    /// Don't run the exploit.
    disabled: bool,
}

/// How to handle situations of the previous run still going while the next one should be started.
#[derive(Debug)]
enum OverrunPolicy {
    /// Stop old exploit run before starting a new run.
    StopOld,
    /// Only keep the still running instance and don't start a new run.
    KeepOldOnly,
    /// Keep the still running instance AND start an additional new run.
    KeepOldAndStartNew,
}

#[derive(Debug)]
pub struct Exploit<'c> {
    /// Command to execute pointing to the exploit script. Expands template patterns.
    command: String,
    /// Specify which teams to attack in which way
    // Map<Team, Policy>
    target_teams: HashMap<&'c Team, &'c Policy>,
    /// Author of the exploit script to contact on problems.
    author: String,
    /// Short description of the exploited vulnerability to distinguish between multiple exploits for the same challenge.
    vuln_title: String,
    /// Challenge name to group exploits.
    target_challenge: String,
    /// Exploit policy to apply by default to all active teams.
    policy: &'c Policy,
    /// Timeout after which the process is killed if it's running too long.
    script_timeout: Duration,
    /// Custom meta key/values which can be accessed in the template patterns.
    meta: HashMap<String, String>,
    /// How to handle situations of the previous run still going while the next one should be started.
    overrun_policy: OverrunPolicy,
    /// Set as the current working directory when starting the exploit script.
    working_directory: &'c Path,
    /// Exploits are never hard deleted, only disabled to preserve history.
    disabled: bool,
}

#[derive(Debug)]
pub struct ExploitRun<'c> {
    /// The exploit that was run.
    exploit: &'c Exploit<'c>,
    /// The targeted team.
    team: &'c Team,
    /// Expanded exploit commandline that was executed.
    command: String,
    /// Time when the exploit process was started.
    starttime: Instant,
    /// Time when the exploit process stopped.
    endtime: Instant,
    /// List of all flags extracted from the output of this run.
    found_flags: [&'c FlagOccurence<'c>],
}


